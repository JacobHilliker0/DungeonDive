Index: Program/src/main/View/screen/CombatScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.View.screen;\r\n\r\nimport javafx.animation.*;\r\nimport javafx.geometry.Insets;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.control.ProgressBar;\r\nimport javafx.scene.control.ScrollPane;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.layout.*;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.text.Text;\r\nimport javafx.stage.Stage;\r\nimport javafx.util.Duration;\r\nimport main.Controller.Controller;\r\nimport main.Model.character.Hero;\r\nimport main.Model.character.Monster;\r\nimport main.Model.dungeon.Room;\r\nimport main.View.GameUI;\r\nimport main.Controller.StateController.GameState;\r\n\r\nimport java.util.List;\r\n\r\npublic class CombatScreen extends Screen {\r\n\r\n    // UI elements\r\n    private VBox topBattlefield;\r\n    private VBox bottomInterface;\r\n    private ProgressBar heroHealthBar;\r\n    private ProgressBar monsterHealthBar;\r\n    private Label heroHealthNumbers;\r\n    private Text heroNameDisplay;\r\n    private Label monsterHealthNumbers;\r\n    private Text monsterNameDisplay;\r\n    private VBox combatMessages;\r\n\r\n    // Sprite containers (could be ImageView or Rectangle)\r\n    private ImageView heroSprite;\r\n    private ImageView monsterSprite;\r\n    private VBox heroSide;\r\n    private VBox monsterSide;\r\n    private javafx.scene.Group heroPlatform;\r\n    private javafx.scene.Group monsterPlatform;\r\n    private javafx.scene.Node selectedNode = null; // To store the currently selected node\r\n    private double nudgeAmount = 1.0; // How many pixels to move per key press\r\n\r\n    // Combat state\r\n    private Hero currentHero;\r\n    private Monster currentMonster;\r\n    private boolean playerTurn = true;\r\n    private boolean combatActive = true;\r\n\r\n    public CombatScreen(final Stage thePrimaryStage, final Controller theController) {\r\n        super(thePrimaryStage, theController);\r\n    }\r\n\r\n    @Override\r\n    public void showScreen(GameUI theUI) {\r\n        showScreen(theUI, null);\r\n    }\r\n\r\n    public void showScreen(GameUI theUI, List<Monster> monsters) {\r\n        testResourceLoading(); // test resources if loading properly\r\n        initializeCombatData();\r\n\r\n        BorderPane root = new BorderPane();\r\n        root.getStyleClass().add(\"combat-root\");\r\n\r\n        createTopBattlefield();\r\n        createBottomInterface();\r\n\r\n        root.setTop(topBattlefield);\r\n        root.setBottom(bottomInterface);\r\n\r\n        Scene combatScene = new Scene(root, 800, 600);\r\n\r\n        getStage().setScene(combatScene);\r\n        getStage().setTitle(\"Combat - \" + (currentHero != null ? currentHero.getName() : \"Hero\") +\r\n                \" vs \" + (currentMonster != null ? currentMonster.getName() : \"Monster\"));\r\n\r\n        // Apply arena background with cobblestone platforms\r\n        applyArenaBackground(root);\r\n\r\n        // Load the CSS file\r\n        try {\r\n            combatScene.getStylesheets().add(\r\n                    getClass().getResource(\"/main/View/css/combat.css\").toExternalForm()\r\n            );\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load combat.css: \" + e.getMessage());\r\n        }\r\n\r\n        getStage().setScene(combatScene);\r\n        getStage().setTitle(\"Combat - \" + (currentHero != null ? currentHero.getName() : \"Hero\") +\r\n                \" vs \" + (currentMonster != null ? currentMonster.getName() : \"Monster\"));\r\n\r\n        getStage().show();\r\n        playEntranceAnimation();\r\n    }\r\n\r\n    private void initializeCombatData() {\r\n        currentHero = getController().getPlayer();\r\n        if (currentHero != null) {\r\n            Room currentRoom = getController().getDungeon().getRoom(currentHero.getPosition());\r\n            List<Monster> monsters = currentRoom.getMonsters();\r\n            currentMonster = monsters.isEmpty() ? null : monsters.get(0);\r\n        }\r\n    }\r\n\r\n    private void createTopBattlefield() {\r\n        topBattlefield = new VBox();\r\n        topBattlefield.setPrefHeight(350);\r\n        topBattlefield.getStyleClass().add(\"battlefield\");\r\n\r\n        HBox battleArea = new HBox();\r\n        battleArea.setAlignment(Pos.CENTER);\r\n        battleArea.setPadding(new Insets(20));\r\n        battleArea.setSpacing(210);\r\n\r\n        VBox heroSide = createHeroSide();\r\n        VBox monsterSide = createMonsterSide();\r\n\r\n        heroSide.setTranslateY(-10);\r\n        heroSide.setTranslateX(-30);\r\n        monsterSide.setTranslateY(-40); // <<< Nudge the hero 10 pixels UP\r\n        monsterSide.setTranslateX(-40);\r\n\r\n        battleArea.getChildren().addAll(heroSide, monsterSide);\r\n        topBattlefield.getChildren().add(battleArea);\r\n    }\r\n\r\n    private VBox createHeroSide() {\r\n        VBox heroSide = new VBox(10);\r\n        heroSide.setAlignment(Pos.CENTER);\r\n\r\n        heroSprite = createHeroSprite();\r\n\r\n        HBox heroInfo = new HBox(10);\r\n        heroInfo.getStyleClass().add(\"combat-info-panel\");\r\n        heroInfo.setAlignment(Pos.CENTER_RIGHT);\r\n\r\n        VBox nameSection = new VBox(3);\r\n        heroNameDisplay = new Text(currentHero != null ? currentHero.getName() : \"Hero\");\r\n        heroNameDisplay.getStyleClass().add(\"combat-name\");\r\n        Text classText = new Text(currentHero != null ? currentHero.getType().getDisplayName() : \"Unknown\");\r\n        classText.getStyleClass().add(\"combat-subtitle\");\r\n        nameSection.getChildren().addAll(heroNameDisplay, classText);\r\n\r\n        VBox healthSection = createHealthSection(true);\r\n\r\n        heroInfo.getChildren().addAll(nameSection, healthSection);\r\n\r\n        heroSide.getChildren().addAll(heroInfo, heroSprite);\r\n\r\n        return heroSide;\r\n    }\r\n\r\n    private VBox createMonsterSide() {\r\n        VBox monsterSide = new VBox(10);\r\n        monsterSide.setAlignment(Pos.CENTER_RIGHT);\r\n\r\n        monsterSprite = createMonsterSprite();\r\n\r\n        // Monster info panel (top)\r\n        HBox monsterInfo = new HBox();\r\n        monsterInfo.getStyleClass().add(\"combat-info-panel\");\r\n        monsterInfo.setAlignment(Pos.CENTER);\r\n\r\n        // Name Section (Left side of HBox)\r\n        VBox nameSection = new VBox(3);\r\n        nameSection.setAlignment(Pos.CENTER_LEFT);\r\n        monsterNameDisplay = new Text(currentMonster != null ? currentMonster.getName() : \"Unknown Monster\");\r\n        monsterNameDisplay.getStyleClass().add(\"combat-name\");\r\n        Text levelText = new Text(\"Lv. \" + (currentMonster != null && currentMonster.isElite() ? \"Elite\" : \"Normal\"));\r\n        levelText.getStyleClass().add(\"combat-subtitle\");\r\n        nameSection.getChildren().addAll(monsterNameDisplay, levelText);\r\n\r\n        // Health Section (Right side of HBox)\r\n        VBox healthSection = createHealthSection(false);\r\n        monsterInfo.getChildren().addAll(nameSection, healthSection);\r\n\r\n        // Add HBox and Sprite to the main VBox\r\n        monsterSide.getChildren().addAll(monsterInfo, monsterSprite);\r\n\r\n        return monsterSide;\r\n    }\r\n\r\n    private ImageView createHeroSprite() {\r\n        ImageView sprite = new ImageView();\r\n        sprite.setFitWidth(120);\r\n        sprite.setFitHeight(120);\r\n        sprite.getStyleClass().add(\"hero-sprite\");\r\n\r\n        // Try to load actual sprite image\r\n        try {\r\n            String spritePath = \"/sprites/heroes/\";\r\n            if (currentHero != null) {\r\n                switch (currentHero.getType()) {\r\n                    case WARRIOR:\r\n                        spritePath += \"warrior.png\";\r\n                        break;\r\n                    case PRIESTESS:\r\n                        spritePath += \"priestess.png\";\r\n                        break;\r\n                    case THIEF:\r\n                        spritePath += \"thief.png\";\r\n                        break;\r\n                    default:\r\n                        spritePath += \"default.png\";\r\n                        break;\r\n                }\r\n            }\r\n            Image heroImage = new Image(getClass().getResourceAsStream(spritePath));\r\n            sprite.setImage(heroImage);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load hero sprite, using fallback\");\r\n            // Create a fallback colored rectangle effect using CSS\r\n            sprite.setStyle(\"-fx-background-color: steelblue; -fx-background-radius: 10px;\");\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    private ImageView createMonsterSprite() {\r\n        ImageView sprite = new ImageView();\r\n        sprite.setFitWidth(140);\r\n        sprite.setFitHeight(140);\r\n        sprite.getStyleClass().add(\"monster-sprite\");\r\n\r\n        // Try to load actual sprite image\r\n        try {\r\n            String spritePath = \"/sprites/monsters/\";\r\n            if (currentMonster != null) {\r\n                spritePath += currentMonster.getType().getName().toLowerCase().replace(\" \", \"_\") + \".png\";\r\n            } else {\r\n                spritePath += \"default.png\";\r\n            }\r\n            Image monsterImage = new Image(getClass().getResourceAsStream(spritePath));\r\n            sprite.setImage(monsterImage);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Could not load monster sprite, using fallback\");\r\n            // Create a fallback colored rectangle effect using CSS\r\n            sprite.setStyle(\"-fx-background-color: darkred; -fx-background-radius: 10px;\");\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    private VBox createHealthSection(boolean isHero) {\r\n        VBox healthSection = new VBox(3);\r\n        healthSection.setAlignment(isHero ? Pos.CENTER_LEFT : Pos.CENTER_RIGHT);\r\n\r\n        Label hpLabel = new Label(\"HP\");\r\n        hpLabel.getStyleClass().add(\"combat-subtitle\");\r\n\r\n        // Create the ProgressBar\r\n        ProgressBar healthBar = new ProgressBar();\r\n        healthBar.getStyleClass().add(\"progress-bar\");\r\n\r\n        // *** FORCE SIZES (for debugging) ***\r\n        healthBar.setPrefWidth(120);\r\n        healthBar.setMinWidth(120); // Force minimum width\r\n        healthBar.setPrefHeight(10);\r\n        healthBar.setMinHeight(10); // Force minimum height\r\n\r\n        if (isHero) {\r\n            heroHealthBar = healthBar;\r\n            heroHealthNumbers = new Label();\r\n            heroHealthNumbers.getStyleClass().add(\"combat-subtitle\");\r\n\r\n            if (currentHero != null) {\r\n                double ratio = currentHero.getHealthPercentage();\r\n                heroHealthNumbers.setText(currentHero.getHealthDisplay());\r\n                updateHealthBar(heroHealthBar, ratio);\r\n            } else {\r\n                heroHealthNumbers.setText(\"0 / 0\");\r\n                heroHealthBar.setProgress(0.0); // Set to 0 if no hero\r\n            }\r\n            healthSection.getChildren().addAll(hpLabel, heroHealthBar, heroHealthNumbers);\r\n\r\n        } else { // Monster\r\n            monsterHealthBar = healthBar;\r\n            monsterHealthNumbers = new Label();\r\n            monsterHealthNumbers.getStyleClass().add(\"combat-subtitle\");\r\n\r\n            if (currentMonster != null) {\r\n                double ratio = currentMonster.getHealthPercentage();\r\n                monsterHealthNumbers.setText(currentMonster.getHealthDisplay());\r\n                updateHealthBar(monsterHealthBar, ratio);\r\n            } else {\r\n                monsterHealthNumbers.setText(\"0 / 0\");\r\n                monsterHealthBar.setProgress(0.0); // Set to 0 if no monster\r\n            }\r\n            healthSection.getChildren().addAll(hpLabel, monsterHealthBar, monsterHealthNumbers);\r\n        }\r\n        return healthSection;\r\n    }\r\n\r\n    private void createBottomInterface() {\r\n        bottomInterface = new VBox();\r\n        bottomInterface.setPrefHeight(250);\r\n        bottomInterface.getStyleClass().add(\"bottom-interface\");\r\n        bottomInterface.setPadding(new Insets(15));\r\n\r\n        // Combat messages\r\n        combatMessages = new VBox(5);\r\n        combatMessages.setPrefHeight(120);\r\n        combatMessages.getStyleClass().add(\"combat-message-area\");\r\n        combatMessages.setAlignment(Pos.BOTTOM_LEFT);\r\n\r\n        ScrollPane messageScroll = new ScrollPane(combatMessages);\r\n        messageScroll.setFitToWidth(true);\r\n        messageScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\r\n        messageScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\r\n        messageScroll.setStyle(\"-fx-background-color: transparent;\");\r\n\r\n        HBox pokemonStyleButtons = createPokemonStyleButtons();\r\n\r\n        bottomInterface.getChildren().addAll(messageScroll, pokemonStyleButtons);\r\n    }\r\n\r\n    private HBox createPokemonStyleButtons() {\r\n        HBox buttonBox = new HBox(15);\r\n        buttonBox.setAlignment(Pos.CENTER);\r\n        buttonBox.setPadding(new Insets(15, 0, 0, 0));\r\n\r\n        Button attackBtn = new Button(\"ATTACK\");\r\n        attackBtn.getStyleClass().addAll(\"combat-button\", \"attack-button\");\r\n\r\n        Button specialBtn = new Button(\r\n                currentHero != null ? currentHero.getType().getSpecialAttackName().toUpperCase() : \"SPECIAL\"\r\n        );\r\n        specialBtn.getStyleClass().addAll(\"combat-button\", \"special-button\");\r\n\r\n        Button itemBtn = new Button(\"ITEM\");\r\n        itemBtn.getStyleClass().addAll(\"combat-button\", \"item-button\");\r\n\r\n        Button runBtn = new Button(\"RUN\");\r\n        runBtn.getStyleClass().addAll(\"combat-button\", \"run-button\");\r\n\r\n        // Set actions\r\n        attackBtn.setOnAction(event -> {\r\n            if (playerTurn && combatActive) {\r\n                performPlayerAttack();\r\n            }\r\n        });\r\n\r\n        specialBtn.setOnAction(event -> {\r\n            if (playerTurn && combatActive) {\r\n                performSpecialAttack();\r\n            }\r\n        });\r\n\r\n        itemBtn.setOnAction(event -> {\r\n            addCombatMessage(\"Item menu - opening inventory...\");\r\n            getController().getGameController().openInventory();\r\n        });\r\n\r\n        runBtn.setOnAction(event -> {\r\n            addCombatMessage(currentHero.getName() + \" tries to run away!\");\r\n            getController().getGameController().playerRun();\r\n        });\r\n\r\n        buttonBox.getChildren().addAll(attackBtn, specialBtn, itemBtn, runBtn);\r\n        return buttonBox;\r\n    }\r\n\r\n    // COMBAT LOGIC\r\n\r\n    private void performPlayerAttack() {\r\n        if (!playerTurn || !combatActive || currentMonster == null) return;\r\n        final Monster attackedMonster = currentMonster;\r\n\r\n        playerTurn = false;\r\n        updateTurnIndicator();\r\n        addCombatMessage(currentHero.getName() + \" uses Attack!\");\r\n\r\n        playAttackAnimation(() -> {\r\n            getController().getGameController().playerAttack();\r\n            updateCombatDisplay();\r\n\r\n            // Re-fetch monster in case it died\r\n            Room currentRoom = getController().getDungeon().getRoom(currentHero.getPosition());\r\n            List<Monster> monsters = currentRoom.getMonsters();\r\n            currentMonster = monsters.isEmpty() ? null : monsters.get(0);\r\n\r\n            if (currentMonster != null && currentMonster.isAlive()) {\r\n                playerTurn = false;\r\n                Timeline delay = new Timeline(new KeyFrame(Duration.seconds(1.5), e -> performMonsterTurn()));\r\n                delay.play();\r\n            } else {\r\n                endCombat(true, attackedMonster);\r\n            }\r\n        });\r\n    }\r\n\r\n    private void performSpecialAttack() {\r\n        if (!playerTurn || !combatActive || currentMonster == null) return;\r\n\r\n        if (currentHero.canUseSpecialAttack()) {\r\n            final Monster attackedMonster = currentMonster;\r\n            playerTurn = false;\r\n            updateTurnIndicator();\r\n            addCombatMessage(currentHero.getName() + \" uses \" + currentHero.getType().getSpecialAttackName() + \"!\");\r\n\r\n            playSpecialAttackAnimation(() -> {\r\n                getController().getGameController().playerSpecialAttack();\r\n                updateCombatDisplay();\r\n\r\n                Room currentRoom = getController().getDungeon().getRoom(currentHero.getPosition());\r\n                List<Monster> monsters = currentRoom.getMonsters();\r\n                currentMonster = monsters.isEmpty() ? null : monsters.get(0);\r\n\r\n                if (currentMonster != null && currentMonster.isAlive()) {\r\n                    playerTurn = false;\r\n                    Timeline delay = new Timeline(new KeyFrame(Duration.seconds(1.5), e -> performMonsterTurn()));\r\n                    delay.play();\r\n                } else {\r\n                    endCombat(true, attackedMonster);\r\n                }\r\n            });\r\n        } else {\r\n            addCombatMessage(\"Cannot use special attack right now!\");\r\n        }\r\n    }\r\n\r\n    private void performMonsterTurn() {\r\n        if (!combatActive || currentMonster == null) return;\r\n\r\n        addCombatMessage(currentMonster.getName() + \" attacks!\");\r\n\r\n        playMonsterAttackAnimation(() -> {\r\n            getController().getGameController().monsterAttacks();\r\n            boolean isGameOver = getController().getGameController().getStateController().isInState(GameState.GAME_OVER);\r\n\r\n            if (isGameOver) {\r\n                // Controller handles showing GameOverScreen. We just show defeat animation.\r\n                endCombat(false);\r\n            } else if (combatActive) {\r\n                // If combat is still active, it's our turn.\r\n                playerTurn = true;\r\n                updateTurnIndicator();\r\n            }\r\n        });\r\n    }\r\n\r\n    // ANIMATIONS\r\n\r\n    private void playEntranceAnimation() {\r\n        // Hero slides in from left\r\n        TranslateTransition heroEntrance = new TranslateTransition(Duration.seconds(1), heroSprite);\r\n        heroEntrance.setFromX(-400);\r\n        heroEntrance.setToX(0);\r\n\r\n        // Monster slides in from right\r\n        TranslateTransition monsterEntrance = new TranslateTransition(Duration.seconds(1), monsterSprite);\r\n        monsterEntrance.setFromX(400);\r\n        monsterEntrance.setToX(0);\r\n\r\n        ParallelTransition entrance = new ParallelTransition(heroEntrance, monsterEntrance);\r\n        entrance.setOnFinished(e -> {\r\n            addCombatMessage(\"A wild \" + (currentMonster != null ? currentMonster.getName() : \"Monster\") + \" appeared!\");\r\n            addCombatMessage(\"What will \" + (currentHero != null ? currentHero.getName() : \"Hero\") + \" do?\");\r\n        });\r\n        entrance.play();\r\n    }\r\n\r\n    private void playAttackAnimation(Runnable onComplete) {\r\n        // Hero moves right towards monster\r\n        Timeline attack = new Timeline(\r\n                new KeyFrame(Duration.millis(0), new KeyValue(heroSprite.translateXProperty(), 0)),\r\n                new KeyFrame(Duration.millis(200), new KeyValue(heroSprite.translateXProperty(), 20)),\r\n                new KeyFrame(Duration.millis(250), new KeyValue(heroSprite.translateXProperty(), 15)),\r\n                new KeyFrame(Duration.millis(300), new KeyValue(heroSprite.translateXProperty(), 25)),\r\n                new KeyFrame(Duration.millis(350), new KeyValue(heroSprite.translateXProperty(), 15)),\r\n                new KeyFrame(Duration.millis(500), new KeyValue(heroSprite.translateXProperty(), 0))\r\n        );\r\n\r\n        attack.setOnFinished(e -> {\r\n            // Flash monster when hit\r\n            FadeTransition flash = new FadeTransition(Duration.millis(100), monsterSprite);\r\n            flash.setFromValue(1.0);\r\n            flash.setToValue(0.3);\r\n            flash.setCycleCount(4);\r\n            flash.setAutoReverse(true);\r\n            flash.setOnFinished(event -> onComplete.run());\r\n            flash.play();\r\n        });\r\n\r\n        attack.play();\r\n    }\r\n\r\n    private void playSpecialAttackAnimation(Runnable onComplete) {\r\n        // More dramatic animation for special attacks\r\n        RotateTransition spin = new RotateTransition(Duration.millis(600), heroSprite);\r\n        spin.setByAngle(360);\r\n\r\n        ScaleTransition grow = new ScaleTransition(Duration.millis(600), heroSprite);\r\n        grow.setToX(1.3);\r\n        grow.setToY(1.3);\r\n        grow.setAutoReverse(true);\r\n        grow.setCycleCount(2);\r\n\r\n        ParallelTransition special = new ParallelTransition(spin, grow);\r\n        special.setOnFinished(e -> {\r\n            // Intense flash on monster\r\n            FadeTransition flash = new FadeTransition(Duration.millis(80), monsterSprite);\r\n            flash.setFromValue(1.0);\r\n            flash.setToValue(0.1);\r\n            flash.setCycleCount(4);\r\n            flash.setAutoReverse(true);\r\n            flash.setOnFinished(event -> onComplete.run());\r\n            flash.play();\r\n        });\r\n\r\n        special.play();\r\n    }\r\n\r\n    private void playMonsterAttackAnimation(Runnable onComplete) {\r\n        // Monster moves left towards hero\r\n        Timeline attack = new Timeline(\r\n                new KeyFrame(Duration.millis(0), new KeyValue(monsterSprite.translateXProperty(), 0)),\r\n                new KeyFrame(Duration.millis(300), new KeyValue(monsterSprite.translateXProperty(), -40)),\r\n                new KeyFrame(Duration.millis(600), new KeyValue(monsterSprite.translateXProperty(), 0))\r\n        );\r\n\r\n        attack.setOnFinished(e -> {\r\n            // Flash hero when hit\r\n            FadeTransition flash = new FadeTransition(Duration.millis(150), heroSprite);\r\n            flash.setFromValue(1.0);\r\n            flash.setToValue(0.4);\r\n            flash.setCycleCount(2);\r\n            flash.setAutoReverse(true);\r\n            flash.setOnFinished(event -> onComplete.run());\r\n            flash.play();\r\n        });\r\n\r\n        attack.play();\r\n    }\r\n\r\n    //  UI UPDATES\r\n\r\n    public void updateCombatDisplay() {\r\n        updateCombatStats();\r\n        updateHealthBars();\r\n    }\r\n\r\n    public void updateDisplay() {\r\n        updateCombatDisplay();\r\n    }\r\n\r\n    public void updateCombatStats() {\r\n        if (currentHero != null) {\r\n            heroNameDisplay.setText(currentHero.getName());\r\n            heroHealthNumbers.setText(currentHero.getHealthDisplay());\r\n        }\r\n\r\n        if (currentMonster != null) {\r\n            monsterNameDisplay.setText(currentMonster.getName());\r\n            if (monsterHealthNumbers != null && currentMonster.getMaxHealth() > 0) {\r\n                monsterHealthNumbers.setText(currentMonster.getHealth() + \" / \" + currentMonster.getMaxHealth());\r\n            } else if (monsterHealthNumbers != null) {\r\n                monsterHealthNumbers.setText(String.valueOf(currentMonster.getHealth()));\r\n            }\r\n        }\r\n    }\r\n\r\n    private void updateHealthBars() {\r\n        if (currentHero != null) {\r\n            double heroHealthRatio = currentHero.getHealthPercentage();\r\n            heroHealthBar.setProgress(heroHealthRatio);\r\n\r\n            Timeline heroHealthAnimation = new Timeline(\r\n                    new KeyFrame(Duration.seconds(0.8),\r\n                            new KeyValue(heroHealthBar.progressProperty(), heroHealthRatio))\r\n            );\r\n            heroHealthAnimation.play();\r\n            updateHealthBar(heroHealthBar, heroHealthRatio);\r\n            if (heroHealthNumbers != null && currentHero.getMaxHealth() > 0) { // Check if max HP exists\r\n                heroHealthNumbers.setText(currentHero.getHealth() + \" / \" + currentHero.getMaxHealth());\r\n            } else if (heroHealthNumbers != null) {\r\n                heroHealthNumbers.setText(String.valueOf(currentHero.getHealth()));\r\n            }\r\n        }\r\n\r\n        if (currentMonster != null) {\r\n            double monsterHealthRatio = currentMonster.getHealthPercentage();\r\n            monsterHealthBar.setProgress(monsterHealthRatio);\r\n\r\n            Timeline monsterHealthAnimation = new Timeline(\r\n                    new KeyFrame(Duration.seconds(0.8),\r\n                            new KeyValue(monsterHealthBar.progressProperty(), monsterHealthRatio))\r\n            );\r\n            monsterHealthAnimation.play();\r\n            updateHealthBar(monsterHealthBar, monsterHealthRatio);\r\n\r\n            if (monsterHealthNumbers != null && currentMonster.getMaxHealth() > 0) { // Check if max HP exists\r\n                monsterHealthNumbers.setText(currentMonster.getHealth() + \" / \" + currentMonster.getMaxHealth());\r\n            } else if (monsterHealthNumbers != null) {\r\n                monsterHealthNumbers.setText(String.valueOf(currentMonster.getHealth()));\r\n            }\r\n        }\r\n    }\r\n\r\n    private void updateHealthBar(ProgressBar healthBar, double ratio) {\r\n        // Remove all health bar style classes\r\n        healthBar.getStyleClass().removeAll(\"health-bar-green\", \"health-bar-orange\", \"health-bar-red\");\r\n\r\n        // Add appropriate style class based on health ratio\r\n        if (ratio > 0.6) {\r\n            healthBar.getStyleClass().add(\"health-bar-green\");\r\n        } else if (ratio > 0.3) {\r\n            healthBar.getStyleClass().add(\"health-bar-orange\");\r\n        } else {\r\n            healthBar.getStyleClass().add(\"health-bar-red\");\r\n        }\r\n    }\r\n\r\n    // COMBAT END\r\n    /**\r\n     * Overloaded endCombat to handle calls that don't need a specific defeated monster.\r\n     * Calls the main endCombat method, passing the current monster (or null if none).\r\n     */\r\n    private void endCombat(boolean victory) {\r\n        // For the defeat case (victory=false), we don't need a specific monster name,\r\n        // so passing currentMonster (which might be null or the last one) is fine.\r\n        endCombat(victory, currentMonster);\r\n    }\r\n\r\n    private void endCombat(boolean victory, Monster monsterForMessage) {\r\n        combatActive = false;\r\n        playerTurn = false;\r\n\r\n        if (victory) {\r\n            String monsterName = (monsterForMessage != null) ? monsterForMessage.getName() : \"The monster\";\r\n            addCombatMessage(monsterName + \" was defeated!\");\r\n            addCombatMessage(currentHero.getName() + \" wins the battle!\");\r\n\r\n            // Victory animation\r\n            RotateTransition victoryRotation = new RotateTransition(Duration.seconds(1), heroSprite);\r\n            victoryRotation.setByAngle(360);\r\n            victoryRotation.play();\r\n\r\n            Timeline endDelay = new Timeline(new KeyFrame(Duration.seconds(3), e -> {\r\n                getController().resumeCurrentGame(getController().getGameController().getGameUI());\r\n            }));\r\n            endDelay.play();\r\n\r\n        } else {\r\n            addCombatMessage(currentHero.getName() + \" was defeated!\");\r\n            addCombatMessage(\"Game Over!\");\r\n\r\n            // Defeat animation\r\n            FadeTransition defeat = new FadeTransition(Duration.seconds(1), heroSprite);\r\n            defeat.setToValue(0.3);\r\n            defeat.play();\r\n        }\r\n    }\r\n\r\n    // ============================================================================\r\n    // MESSAGE SYSTEM\r\n    // ============================================================================\r\n\r\n    public void addGameMessage(String message) {\r\n        addCombatMessage(message);\r\n    }\r\n\r\n    private void addCombatMessage(String message) {\r\n        Label messageLabel = new Label(message);\r\n        messageLabel.getStyleClass().add(\"combat-message\");\r\n        messageLabel.setMaxWidth(700);\r\n\r\n        combatMessages.getChildren().add(messageLabel);\r\n\r\n        // Keep only last 6 messages\r\n        if (combatMessages.getChildren().size() > 6) {\r\n            combatMessages.getChildren().remove(0);\r\n        }\r\n\r\n        // Typing effect animation\r\n        animateTyping(messageLabel, message);\r\n    }\r\n\r\n    private void animateTyping(Label label, String fullText) {\r\n        Timeline typing = new Timeline();\r\n        label.setText(\"\");\r\n\r\n        for (int i = 0; i <= fullText.length(); i++) {\r\n            final int index = i;\r\n            typing.getKeyFrames().add(\r\n                    new KeyFrame(Duration.millis(i * 25),\r\n                            e -> label.setText(fullText.substring(0, index)))\r\n            );\r\n        }\r\n        typing.play();\r\n    }\r\n\r\n    // ENHANCED VISUAL EFFECTS\r\n\r\n    /**\r\n     * Adds a screen shake effect for powerful attacks\r\n     */\r\n    private void addScreenShake() {\r\n        Timeline shake = new Timeline(\r\n                new KeyFrame(Duration.millis(0), new KeyValue(topBattlefield.translateXProperty(), 0)),\r\n                new KeyFrame(Duration.millis(50), new KeyValue(topBattlefield.translateXProperty(), -5)),\r\n                new KeyFrame(Duration.millis(100), new KeyValue(topBattlefield.translateXProperty(), 5)),\r\n                new KeyFrame(Duration.millis(150), new KeyValue(topBattlefield.translateXProperty(), -3)),\r\n                new KeyFrame(Duration.millis(200), new KeyValue(topBattlefield.translateXProperty(), 3)),\r\n                new KeyFrame(Duration.millis(250), new KeyValue(topBattlefield.translateXProperty(), 0))\r\n        );\r\n        shake.play();\r\n    }\r\n\r\n    /**\r\n     * Shows floating damage numbers above sprites\r\n     * @param damage Amount of damage to display\r\n     * @param isPlayerAttack True if player dealt the damage, false if monster did\r\n     */\r\n    private void showFloatingDamageNumber(int damage, boolean isPlayerAttack) {\r\n        Label damageLabel = new Label(\"-\" + damage);\r\n        damageLabel.setStyle(\"-fx-font-size: 18px; -fx-font-weight: bold; \" +\r\n                \"-fx-text-fill: \" + (isPlayerAttack ? \"red\" : \"blue\") + \";\");\r\n\r\n        // Position above the target\r\n        double startX = isPlayerAttack ?\r\n                monsterSprite.getLayoutX() + monsterSprite.getBoundsInLocal().getWidth() / 2 :\r\n                heroSprite.getLayoutX() + heroSprite.getBoundsInLocal().getWidth() / 2;\r\n        double startY = isPlayerAttack ?\r\n                monsterSprite.getLayoutY() :\r\n                heroSprite.getLayoutY();\r\n\r\n        damageLabel.setLayoutX(startX);\r\n        damageLabel.setLayoutY(startY);\r\n\r\n        // Add to battlefield temporarily\r\n        topBattlefield.getChildren().add(damageLabel);\r\n\r\n        // Animate upward and fade out\r\n        Timeline floatAnimation = new Timeline(\r\n                new KeyFrame(Duration.seconds(1.5),\r\n                        new KeyValue(damageLabel.layoutYProperty(), startY - 50),\r\n                        new KeyValue(damageLabel.opacityProperty(), 0)\r\n                )\r\n        );\r\n\r\n        floatAnimation.setOnFinished(e -> topBattlefield.getChildren().remove(damageLabel));\r\n        floatAnimation.play();\r\n    }\r\n\r\n    /**\r\n     * Shows special status effects (like critical hits, buffs, debuffs)\r\n     * @param effectName Name of the effect\r\n     * @param effectColor Color of the effect text\r\n     * @param isForHero True if effect is on hero, false if on monster\r\n     */\r\n    public void showStatusEffect(String effectName, Color effectColor, boolean isForHero) {\r\n        Label statusLabel = new Label(effectName);\r\n        statusLabel.setTextFill(effectColor);\r\n        statusLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold;\");\r\n\r\n        // Position above character\r\n        ImageView targetSprite = isForHero ? heroSprite : monsterSprite;\r\n        statusLabel.setLayoutX(targetSprite.getLayoutX() + targetSprite.getBoundsInLocal().getWidth() / 2);\r\n        statusLabel.setLayoutY(targetSprite.getLayoutY() - 20);\r\n\r\n        // Add to scene temporarily\r\n        topBattlefield.getChildren().add(statusLabel);\r\n\r\n        // Fade out and remove\r\n        FadeTransition fadeOut = new FadeTransition(Duration.seconds(2), statusLabel);\r\n        fadeOut.setToValue(0);\r\n        fadeOut.setOnFinished(e -> topBattlefield.getChildren().remove(statusLabel));\r\n        fadeOut.play();\r\n    }\r\n\r\n    /**\r\n     * Enhanced critical hit animation\r\n     */\r\n    public void playCriticalHitAnimation() {\r\n        addCombatMessage(\"Critical Hit!\");\r\n\r\n        // Golden flash effect\r\n        FadeTransition critFlash = new FadeTransition(Duration.millis(200), monsterSprite);\r\n        critFlash.setFromValue(1.0);\r\n        critFlash.setToValue(0.3);\r\n        critFlash.setCycleCount(4);\r\n        critFlash.setAutoReverse(true);\r\n\r\n        // Scale animation\r\n        ScaleTransition critScale = new ScaleTransition(Duration.millis(400), heroSprite);\r\n        critScale.setToX(1.4);\r\n        critScale.setToY(1.4);\r\n        critScale.setAutoReverse(true);\r\n        critScale.setCycleCount(2);\r\n\r\n        ParallelTransition criticalHit = new ParallelTransition(critFlash, critScale);\r\n        criticalHit.play();\r\n\r\n        // Show status effect\r\n        showStatusEffect(\"CRITICAL!\", Color.GOLD, true);\r\n\r\n        // Screen shake\r\n        addScreenShake();\r\n    }\r\n\r\n    // ============================================================================\r\n    // UTILITY METHODS\r\n    // ============================================================================\r\n\r\n    /**\r\n     * Gets the current combat state for external queries\r\n     * @return True if combat is currently active\r\n     */\r\n    public boolean isCombatActive() {\r\n        return combatActive;\r\n    }\r\n\r\n    /**\r\n     * Gets the current player turn state\r\n     * @return True if it's currently the player's turn\r\n     */\r\n    public boolean isPlayerTurn() {\r\n        return playerTurn;\r\n    }\r\n\r\n    /**\r\n     * Updates the turn indicator (if you want to add visual turn indicators)\r\n     */\r\n    private void updateTurnIndicator() {\r\n        // You can add visual indicators here to show whose turn it is\r\n        if (playerTurn) {\r\n            heroSprite.setEffect(new javafx.scene.effect.DropShadow(10, Color.CYAN));\r\n            monsterSprite.setEffect(null);\r\n        } else {\r\n            monsterSprite.setEffect(new javafx.scene.effect.DropShadow(10, Color.RED));\r\n            heroSprite.setEffect(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test method to verify all resources are loading correctly\r\n     */\r\n    private void testResourceLoading() {\r\n        System.out.println(\"=== TESTING COMBAT SCREEN RESOURCES ===\");\r\n\r\n        // Test CSS loading\r\n        try {\r\n            String cssPath = \"/main/View/css/combat.css\";\r\n            var cssUrl = getClass().getResource(cssPath);\r\n            if (cssUrl != null) {\r\n                System.out.println(\"✅ CSS found: \" + cssPath);\r\n            } else {\r\n                System.out.println(\"❌ CSS NOT found: \" + cssPath);\r\n            }\r\n        } catch (Exception e) {\r\n            System.out.println(\"❌ CSS loading failed: \" + e.getMessage());\r\n        }\r\n\r\n        // Test sprite loading\r\n        String[] testSprites = {\r\n                \"/sprites/heroes/warrior.png\",\r\n                \"/sprites/heroes/priestess.png\",\r\n                \"/sprites/heroes/thief.png\",\r\n                \"/sprites/monsters/goblin.png\"\r\n        };\r\n\r\n        for (String spritePath : testSprites) {\r\n            try {\r\n                var spriteUrl = getClass().getResource(spritePath);\r\n                if (spriteUrl != null) {\r\n                    System.out.println(\"✅ Sprite found: \" + spritePath);\r\n                } else {\r\n                    System.out.println(\"❌ Sprite NOT found: \" + spritePath);\r\n                }\r\n            } catch (Exception e) {\r\n                System.out.println(\"❌ Sprite loading failed: \" + spritePath + \" - \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        System.out.println(\"=== END RESOURCE TEST ===\");\r\n    }\r\n\r\n    // DEBUGGING METHODS (Remove later)\r\n\r\n    /**\r\n     * Debug method to simulate combat scenarios\r\n     * Call this temporarily to test different combat situations\r\n     */\r\n    public void debugCombat() {\r\n        System.out.println(\"=== COMBAT DEBUG INFO ===\");\r\n        System.out.println(\"Combat Active: \" + combatActive);\r\n        System.out.println(\"Player Turn: \" + playerTurn);\r\n        System.out.println(\"Hero: \" + (currentHero != null ? currentHero.getName() : \"null\"));\r\n        System.out.println(\"Monster: \" + (currentMonster != null ? currentMonster.getName() : \"null\"));\r\n        if (currentHero != null) {\r\n            System.out.println(\"Hero Health: \" + currentHero.getHealth() + \"/\" + currentHero.getMaxHealth());\r\n        }\r\n        if (currentMonster != null) {\r\n            System.out.println(\"Monster Health: \" + currentMonster.getHealth());\r\n        }\r\n        System.out.println(\"=== END DEBUG INFO ===\");\r\n    }\r\n\r\n    // ARENA BACKGROUND WITH CUSTOM PLATFORMS\r\n\r\n    /**\r\n     * Apply arena-style background with gray gradients and round cobblestone platforms\r\n     */\r\n    private void applyArenaBackground(BorderPane root) {\r\n        // Battlefield area\r\n        topBattlefield.setStyle(\"-fx-background-color: transparent;\");\r\n\r\n        // Create the cobblestone platforms\r\n        createBattlePlatforms();\r\n    }\r\n\r\n    /**\r\n     * Creates a Pokémon-style battle platform (flatter, elliptical).\r\n     * @param centerX X position of platform center\r\n     * @param centerY Y position of platform center\r\n     * @param radiusX Radius of the ellipse on the X-axis\r\n     * @param radiusY Radius of the ellipse on the Y-axis\r\n     * @return Group containing the platform graphics\r\n     */\r\n    private javafx.scene.Group createPokemonStylePlatform(double centerX, double centerY, double radiusX, double radiusY) {\r\n        javafx.scene.Group platformGroup = new javafx.scene.Group();\r\n\r\n        javafx.scene.shape.Ellipse baseEllipse = new javafx.scene.shape.Ellipse(centerX, centerY, radiusX, radiusY);\r\n\r\n        // A semi-transparent, slightly glowing pad\r\n        baseEllipse.setFill(javafx.scene.paint.Color.rgb(150, 150, 220, 0.3)); // Light blue/purple, semi-transparent\r\n        baseEllipse.setStroke(javafx.scene.paint.Color.rgb(200, 200, 255, 0.7)); // Lighter stroke\r\n        baseEllipse.setStrokeWidth(2);\r\n\r\n        javafx.scene.effect.Bloom bloomEffect = new javafx.scene.effect.Bloom();\r\n        bloomEffect.setThreshold(0.6);\r\n        baseEllipse.setEffect(bloomEffect);\r\n\r\n        platformGroup.getChildren().add(baseEllipse);\r\n\r\n        // subtle inner pattern or texture if desired,\r\n        javafx.scene.shape.Ellipse innerAccent = new javafx.scene.shape.Ellipse(centerX, centerY, radiusX * 0.7, radiusY * 0.7);\r\n        innerAccent.setFill(javafx.scene.paint.Color.TRANSPARENT);\r\n        innerAccent.setStroke(javafx.scene.paint.Color.rgb(200, 200, 255, 0.4));\r\n        innerAccent.setStrokeWidth(1.5);\r\n        innerAccent.getStrokeDashArray().addAll(5d, 5d); // Dashed line\r\n        platformGroup.getChildren().add(innerAccent);\r\n\r\n        return platformGroup;\r\n    }\r\n\r\n    /**\r\n     * Create battle platforms for hero and monster using the new style.\r\n     */\r\n    private void createBattlePlatforms() {\r\n        // Remove any existing platform layers first\r\n        topBattlefield.getChildren().removeIf(node ->\r\n                node.getUserData() != null && node.getUserData().equals(\"platform-layer\"));\r\n\r\n        javafx.scene.layout.Pane platformLayer = new javafx.scene.layout.Pane();\r\n        platformLayer.setUserData(\"platform-layer\");\r\n        platformLayer.setMouseTransparent(true);\r\n\r\n        double heroPlatformCenterX = 160;\r\n        double heroPlatformCenterY = 288;\r\n        double heroPlatformRadiusX = 90;\r\n        double heroPlatformRadiusY = 45;\r\n\r\n        heroPlatform = createPokemonStylePlatform(\r\n                heroPlatformCenterX, heroPlatformCenterY, heroPlatformRadiusX, heroPlatformRadiusY);\r\n\r\n\r\n        // Monster platform (top-rightish, or centered opposite hero)\r\n        double monsterPlatformCenterX = 604;\r\n        double monsterPlatformCenterY = 256;\r\n        double monsterPlatformRadiusX = 100;\r\n        double monsterPlatformRadiusY = 50;\r\n\r\n        monsterPlatform = createPokemonStylePlatform(\r\n                monsterPlatformCenterX, monsterPlatformCenterY, monsterPlatformRadiusX, monsterPlatformRadiusY);\r\n\r\n        platformLayer.getChildren().addAll(heroPlatform, monsterPlatform);\r\n        // Ensure platforms are drawn but don't force VBox height\r\n        platformLayer.setPrefHeight(350); // Match battlefield height\r\n        topBattlefield.getChildren().add(0, platformLayer);    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Program/src/main/View/screen/CombatScreen.java b/Program/src/main/View/screen/CombatScreen.java
--- a/Program/src/main/View/screen/CombatScreen.java	(revision 80977221b35f902944bc6b1ac393886e0b91f9e7)
+++ b/Program/src/main/View/screen/CombatScreen.java	(date 1748410058386)
@@ -40,12 +40,8 @@
     // Sprite containers (could be ImageView or Rectangle)
     private ImageView heroSprite;
     private ImageView monsterSprite;
-    private VBox heroSide;
-    private VBox monsterSide;
     private javafx.scene.Group heroPlatform;
     private javafx.scene.Group monsterPlatform;
-    private javafx.scene.Node selectedNode = null; // To store the currently selected node
-    private double nudgeAmount = 1.0; // How many pixels to move per key press
 
     // Combat state
     private Hero currentHero;
Index: Program/src/test/Model/character/CharacterTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package test.Model.character;\r\n\r\nimport main.Model.character.Character;\r\nimport main.Model.util.Direction;\r\nimport main.Model.util.Point;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\n/**\r\n * Unit tests for the abstract Character class.\r\n * Note: The abstract attack() method is tested in concrete subclasses (HeroTest, MonsterTest).\r\n */\r\nclass CharacterTest {\r\n\r\n    // A concrete implementation of Character for testing purposes\r\n    private static class ConcreteCharacter extends main.Model.character.Character {\r\n        public ConcreteCharacter(int health, Point position) {\r\n            super(health, position);\r\n        }\r\n\r\n        @Override\r\n        public int attack(Character target) {\r\n            // Simple attack for testing, could be more complex\r\n            int damage = 10;\r\n            if (target != null) {\r\n                target.takeDamage(damage);\r\n            }\r\n            return damage;\r\n        }\r\n    }\r\n\r\n    private ConcreteCharacter character;\r\n    private ConcreteCharacter targetCharacter;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        character = new ConcreteCharacter(100, new Point(0, 0));\r\n        targetCharacter = new ConcreteCharacter(50, new Point(1,1));\r\n    }\r\n\r\n    @Test\r\n    void constructor_initializesHealthAndPosition() {\r\n        assertEquals(100, character.getHealth(), \"Initial health should be set by constructor.\");\r\n        assertEquals(new Point(0, 0), character.getPosition(), \"Initial position should be set by constructor.\");\r\n    }\r\n\r\n    @Test\r\n    void takeDamage_reducesHealth() {\r\n        character.takeDamage(30);\r\n        assertEquals(70, character.getHealth(), \"Health should be reduced by damage amount.\");\r\n    }\r\n\r\n    @Test\r\n    void takeDamage_healthDoesNotGoBelowZero() {\r\n        character.takeDamage(150); // More damage than current health\r\n        assertEquals(0, character.getHealth(), \"Health should not go below zero.\");\r\n    }\r\n\r\n    @Test\r\n    void isAlive_returnsTrueWhenHealthAboveZero() {\r\n        assertTrue(character.isAlive(), \"Character should be alive when health > 0.\");\r\n    }\r\n\r\n    @Test\r\n    void isAlive_returnsFalseWhenHealthIsZero() {\r\n        character.takeDamage(100);\r\n        assertFalse(character.isAlive(), \"Character should not be alive when health is 0.\");\r\n    }\r\n\r\n    @Test\r\n    void move_north_updatesPositionCorrectly() {\r\n        character.move(Direction.NORTH);\r\n        assertEquals(new Point(0, -1), character.getPosition(), \"Position should update correctly for NORTH movement.\");\r\n    }\r\n\r\n    @Test\r\n    void move_south_updatesPositionCorrectly() {\r\n        character.move(Direction.SOUTH);\r\n        assertEquals(new Point(0, 1), character.getPosition(), \"Position should update correctly for SOUTH movement.\");\r\n    }\r\n\r\n    @Test\r\n    void move_east_updatesPositionCorrectly() {\r\n        character.move(Direction.EAST);\r\n        assertEquals(new Point(1, 0), character.getPosition(), \"Position should update correctly for EAST movement.\");\r\n    }\r\n\r\n    @Test\r\n    void move_west_updatesPositionCorrectly() {\r\n        character.move(Direction.WEST);\r\n        assertEquals(new Point(-1, 0), character.getPosition(), \"Position should update correctly for WEST movement.\");\r\n    }\r\n\r\n    @Test\r\n    void setHealth_updatesHealth() {\r\n        character.setHealth(80);\r\n        assertEquals(80, character.getHealth(), \"setHealth should update the health value.\");\r\n    }\r\n\r\n    @Test\r\n    void setPosition_updatesPosition() {\r\n        Point newPosition = new Point(5, 5);\r\n        character.setPosition(newPosition);\r\n        assertEquals(newPosition, character.getPosition(), \"setPosition should update the position value.\");\r\n    }\r\n\r\n    @Test\r\n    void concreteCharacterAttack_damagesTarget() {\r\n        int initialTargetHealth = targetCharacter.getHealth();\r\n        character.attack(targetCharacter);\r\n        assertTrue(targetCharacter.getHealth() < initialTargetHealth, \"Target character health should decrease after attack.\");\r\n        assertEquals(initialTargetHealth - 10, targetCharacter.getHealth(), \"Target health should be reduced by attack damage.\");\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Program/src/test/Model/character/CharacterTest.java b/Program/src/test/Model/character/CharacterTest.java
--- a/Program/src/test/Model/character/CharacterTest.java	(revision 80977221b35f902944bc6b1ac393886e0b91f9e7)
+++ b/Program/src/test/Model/character/CharacterTest.java	(date 1748453267866)
@@ -9,12 +9,12 @@
 
 /**
  * Unit tests for the abstract Character class.
- * Note: The abstract attack() method is tested in concrete subclasses (HeroTest, MonsterTest).
+ * Note: The abstract attack() method is tested in concrete subclasses (HeroTest, MonssterTest).
  */
 class CharacterTest {
 
     // A concrete implementation of Character for testing purposes
-    private static class ConcreteCharacter extends main.Model.character.Character {
+    private static class ConcreteCharacter extends Character {
         public ConcreteCharacter(int health, Point position) {
             super(health, position);
         }
Index: out/production/DungeonDive/main/View/css/combat.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ============================================================================ */\r\n/* BASIC SETUP & BACKGROUND                                                     */\r\n/* ============================================================================ */\r\n.combat-root {\r\n    -fx-background-color: #000000;\r\n}\r\n\r\n.battlefield {\r\n    -fx-background-image: url(\"/sprites/backgrounds/combat_background.png\");\r\n    -fx-background-size: 100% 100%;\r\n    -fx-background-position: center center;\r\n    -fx-background-repeat: no-repeat;\r\n}\r\n\r\n/* ============================================================================ */\r\n/* BOTTOM INTERFACE (The Main Text Box)                                         */\r\n/* ============================================================================ */\r\n.bottom-interface {\r\n    -fx-background-color: #F8F8F8; /* Very light gray/white */\r\n    -fx-border-color: #00008B; /* Dark Blue */\r\n    -fx-border-width: 5px 6px 6px 5px; /* Thicker bottom/right for pseudo-3D */\r\n    -fx-border-radius: 10px;\r\n    -fx-background-radius: 10px;\r\n    -fx-padding: 10px; /* Padding inside the blue border */\r\n    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.4), 8, 0.2, 2, 3);\r\n}\r\n\r\n/* ============================================================================ */\r\n/* COMBAT MESSAGE AREA (Inner Box)                                              */\r\n/* ============================================================================ */\r\n.combat-message-area {\r\n    -fx-background-color: #FFFFFF; /* White inner box */\r\n    -fx-border-color: #4682B4; /* Steel Blue border */\r\n    -fx-border-width: 3px;\r\n    -fx-border-radius: 5px;\r\n    -fx-background-radius: 5px;\r\n    -fx-padding: 10px;\r\n    -fx-pref-height: 120px; /* Ensure consistent height */\r\n    -fx-margin-bottom: 15px; /* Space between messages and buttons */\r\n}\r\n\r\n/* Make ScrollPane holding messages transparent */\r\n.scroll-pane {\r\n    -fx-background-color: transparent;\r\n    -fx-border-color: transparent;\r\n}\r\n\r\n.scroll-pane .viewport {\r\n    -fx-background-color: transparent;\r\n}\r\n\r\n/* --- Combat Messages (Text) --- */\r\n.combat-message {\r\n    -fx-text-fill: #1E1E1E; /* Dark Gray / Black text */\r\n    -fx-font-family: \"Consolas\", \"Courier New\", monospace; /* Pixel-friendly font */\r\n    -fx-font-size: 15px;\r\n    -fx-font-weight: bold;\r\n    -fx-wrap-text: true;\r\n}\r\n\r\n/* ============================================================================ */\r\n/* BUTTONS                                                                      */\r\n/* ============================================================================ */\r\n/* Container for buttons - adjust if you want a 2x2 grid later */\r\n.pokemon-style-buttons {\r\n    -fx-alignment: center;\r\n    -fx-spacing: 20px;\r\n}\r\n\r\n.combat-button {\r\n    -fx-background-color: #E8E8E8; /* Light gray base */\r\n    -fx-text-fill: #333333; /* Dark text */\r\n    -fx-font-family: \"Arial\", sans-serif;\r\n    -fx-font-size: 15px;\r\n    -fx-font-weight: bold;\r\n    -fx-border-color: #666666; /* Medium Gray border */\r\n    -fx-border-width: 1px 2px 2px 1px; /* Pseudo-3D border */\r\n    -fx-border-radius: 5px;\r\n    -fx-background-radius: 5px;\r\n    -fx-padding: 10px 20px;\r\n    -fx-min-width: 100px; /* Give buttons some width */\r\n    -fx-cursor: hand; /* Show hand cursor on hover */\r\n}\r\n\r\n.combat-button:hover {\r\n    -fx-background-color: #FFFFFF; /* White on hover */\r\n    -fx-border-color: #000000;\r\n}\r\n\r\n.combat-button:pressed {\r\n    -fx-background-color: #D0D0D0; /* Darker when pressed */\r\n    -fx-border-width: 2px 1px 1px 2px; /* Invert border for pressed effect */\r\n}\r\n\r\n/* --- Specific Button Colors (Optional, uses -fx-base) --- */\r\n/* For these to work well, you might need a more complex background definition */\r\n/* or just set -fx-background-color directly */\r\n.attack-button { -fx-background-color: #FF7F7F; } /* Lighter Red */\r\n.attack-button:hover { -fx-background-color: #FF5555; }\r\n.special-button { -fx-background-color: #BF7FFF; } /* Lighter Purple */\r\n.special-button:hover { -fx-background-color: #AA55FF; }\r\n.item-button { -fx-background-color: #7FFF7F; } /* Lighter Green */\r\n.item-button:hover { -fx-background-color: #55FF55; }\r\n.run-button { -fx-background-color: #FFFF7F; } /* Lighter Yellow */\r\n.run-button:hover { -fx-background-color: #FFFF55; }\r\n\r\n/* ============================================================================ */\r\n/* INFO & HEALTH BARS                                                           */\r\n/* ============================================================================ */\r\n.combat-info-panel {\r\n    -fx-background-color: rgba(245, 245, 245, 0.85); /* Slightly transparent white */\r\n    -fx-border-color: #555555;\r\n    -fx-border-width: 3px;\r\n    -fx-border-radius: 8px;\r\n    -fx-background-radius: 8px;\r\n    -fx-padding: 8px 12px;\r\n    -fx-effect: dropshadow(two-pass-box, rgba(0,0,0,0.3), 5, 0.1, 1, 1);\r\n}\r\n\r\n.combat-name {\r\n    -fx-font-size: 16px;\r\n    -fx-font-weight: bold;\r\n    -fx-fill: #111111;\r\n}\r\n\r\n.combat-subtitle {\r\n    -fx-font-size: 12px;\r\n    -fx-font-style: italic;\r\n    -fx-fill: #333333;\r\n}\r\n\r\n/* Health Bar Styling */\r\n.progress-bar {\r\n    -fx-background-color: #FFFFFF; /* White background */\r\n    -fx-border-color: #444444;\r\n    -fx-border-radius: 5px;\r\n    -fx-background-radius: 5px;\r\n    -fx-padding: 1px; /* Small padding to show border */\r\n    -fx-pref-height: 12px; /* Thinner health bar */\r\n}\r\n\r\n.progress-bar .bar {\r\n    -fx-background-insets: 0;\r\n    -fx-padding: 0; /* No padding on the bar itself */\r\n    -fx-border-radius: 4px; /* Slightly less than parent */\r\n    -fx-background-radius: 4px;\r\n}\r\n\r\n.health-bar-green .bar {\r\n    -fx-background-color: #00FF00; /* Bright Green */\r\n}\r\n.health-bar-orange .bar {\r\n    -fx-background-color: #FFA500; /* Bright Orange */\r\n}\r\n.health-bar-red .bar {\r\n    -fx-background-color: #FF0000; /* Bright Red */\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/DungeonDive/main/View/css/combat.css b/out/production/DungeonDive/main/View/css/combat.css
--- a/out/production/DungeonDive/main/View/css/combat.css	(revision 80977221b35f902944bc6b1ac393886e0b91f9e7)
+++ b/out/production/DungeonDive/main/View/css/combat.css	(date 1748388549302)
@@ -61,7 +61,6 @@
 /* ============================================================================ */
 /* BUTTONS                                                                      */
 /* ============================================================================ */
-/* Container for buttons - adjust if you want a 2x2 grid later */
 .pokemon-style-buttons {
     -fx-alignment: center;
     -fx-spacing: 20px;
@@ -92,9 +91,7 @@
     -fx-border-width: 2px 1px 1px 2px; /* Invert border for pressed effect */
 }
 
-/* --- Specific Button Colors (Optional, uses -fx-base) --- */
-/* For these to work well, you might need a more complex background definition */
-/* or just set -fx-background-color directly */
+/* --- Specific Button Colors --- */
 .attack-button { -fx-background-color: #FF7F7F; } /* Lighter Red */
 .attack-button:hover { -fx-background-color: #FF5555; }
 .special-button { -fx-background-color: #BF7FFF; } /* Lighter Purple */
